import pandas as pd
import numpy as np

# 1.
# Задать два двухмерных массива ar1 и ar2 размерности (10, 4), состоящих из случайных целых чисел в пределах от -5 до 5.
# Удвоить все значения ar1, которые больше значений ar2, расположенных на аналогичных позициях, остальные значения сделать равными 0.
# Решить задачу средствами numpy и/или pandas. Не использовать циклы и конструкции стандартного Python там, где можно использовать возможности данных библиотек.
#
# 1
print(f"\nЗадание 1\n")
ar1 = np.random.randint(-5, 6, size=(10, 4)) # Создаем два массива случайных чисел от -5 до 5 размерности (10, 4)
ar2 = np.random.randint(-5, 6, size=(10, 4))

result = np.where(ar1 > ar2, ar1 * 2, 0) # Удваиваем значения в ar1, где они больше соответствующих значений в ar2. Остальные значения делаем равными -//-.

print("Массив ar1:")
print(ar1)
print("\nМассив ar2:")
print(ar2)
print("\nРезультат:")
print(result)
#
# 2.
# Задан двухмерный массив ar1 размерности (25, 4), состоящий из случайных целых чисел в пределах от 0 до 15.
# Определить, в каких столбцах не менее 5 раз встречается значение, максимальное по своей строке
# (вывести индексы этих столбцов на экран с соответствующим комментарием).
# Для столбца, в котором таких значений наибольшее количество, заменить максимумы по строке на значения -1.
# Решить задачу средствами numpy и/или pandas. Не использовать циклы и конструкции стандартного Python там, где можно использовать возможности данных библиотек.
#
# 2
print(f"\nЗадание 2\n")
arr1 = np.random.randint(0, 16, size=(25, 4)) # Создаем массив случайных чисел от 0 до 15 размерности (25, 4)
print(f"\nМассив до заммены: {arr1}\n")
max_in_rows = np.max(arr1, axis=1, keepdims=True) # Находим максимальные значения в каждой строке; keepdims=True для сохранения размерности

is_max = arr1 == max_in_rows # Маска, где True соответствует максимальным значениям в строках == axis=1
max_counts_per_col = np.sum(is_max, axis=0) # Считаем количество максимальных по строкам значений в каждом столбце == axis=0

cols_with_5max = np.where(max_counts_per_col >= 5)[0] # Находим столбцы, где не менее 5 максимальных по строкам значений
print("Индексы столбцов, где не менее 5 максимальных по строке значений:", cols_with_5max)

col_with_most_max = np.argmax(max_counts_per_col) # Находим столбец с наибольшим количеством максимальных по строкам значений
arr1[is_max[:, col_with_most_max], col_with_most_max] = -1 # Заменяем максимальные по строкам значения в этом столбце на -1
print("\nМассив после замены:")
print(arr1)
#
# 3.Создать двухмерный массив 30 на 4, содержащий случайные целые числа от 0 до 100.
# Интерпретируя массив как 30 векторов из 4х компонент, вернуть массив 5 на 4, состоящий из векторов с наибольшей длиной (евклидовой нормой).
# Решить задачу средствами numpy и/или pandas. Не использовать циклы и конструкции стандартного Python там, где можно использовать возможности данных библиотек.
#
# Создание массива: np.random.randint(0, 101, size=(30, 4)) генерирует массив 30×4 со значениями 0-100.
#
# Вычисление норм: np.linalg.norm(vectors, axis=1) вычисляет евклидову норму каждого вектора (√(x₁² + x₂² + x₃² + x₄²)).
#
# Сортировка индексов: np.argsort(norms) возвращает индексы, сортированные по возрастанию норм, а [-5:] выбирает последние 5 (с наибольшими нормами).
#
# Выбор векторов: vectors[top5_indices] извлекает 5 векторов с наибольшими нормами.
#
# 3
print(f"\nЗадание 3\n")
vectors = np.random.randint(0, 101, size=(30, 4)) # Создаем массив 30x4 со случайными числами от 0 до 100
norms = np.linalg.norm(vectors, axis=1) # Вычисляем евклидову норму (длину) каждого вектора
top5_indices = np.argsort(norms)[-5:] # Находим индексы 5 векторов с наибольшей длиной
top5_vectors = vectors[top5_indices] # Выбираем эти 5 векторов
print("Исходный массив (первые 5 векторов для примера):")
print(vectors[:5])
print("\n5 векторов с наибольшей длиной:")
print(top5_vectors)
#
# 4.
# Построить "one-hot encoding" для одномерного массива numpy из целых неотрицательных чисел
# (длина массива и максимальное значение в массиве заранее неизвестно).
# Протестировать свое решение на случайно сгенерированном одномерном массиве, соответствующем условию.
# Пример "one-hot encoding": для вектора `np.array([2, 3, 2, 2, 2, 1])` ожидается результат:
# Решить задачу средствами numpy и/или pandas. Не использовать циклы и конструкции стандартного Python там, где можно использовать возможности данных библиотек.
#
# np.max(arr) + 1 определяет количество уникальных классов (максимальное значение + 1)
# np.eye(num_classes) создает единичную матрицу размером num_classes × num_classes
# Индексация [arr] выбирает соответствующие строки из единичной матрицы
#
# 4
print(f"\nЗадание 4\n")
def one_hot_encode(arr):
    num_classes = np.max(arr) + 1 # Получаем максимальное значение для определения количества классов
    return np.eye(num_classes)[arr] # Создаем one-hot encoding с помощью np.eye

random_arr = np.random.randint(0, 5, size=10)  # Случайные числа от 0 до 4 # Тестирование на случайном массиве
print("Исходный массив:", random_arr)
print("One-hot encoding:")
print(one_hot_encode(random_arr))

test_arr = np.array([2, 3, 2, 2, 2, 1]) # Тест на примере из задания
print("\nТестовый массив:", test_arr)
print("One-hot encoding:")
print(one_hot_encode(test_arr))
#
# 5.
# Создать массив `arr` размерности (10, 4) из случайных целых чисел от 0 до 50.
# Найти самое частое число в массиве (вывести на экран его значение и информацию о расположении всех этих значений в исходном массиве).
# Вернуть массив (3, 4) содержащий 3 строки из исходного массива, содержащие наибольшее количество самых частотных значений.
# Код должен корректно работать в случае, если сразу несколько чисел являются самыми частотными.
# Решить задачу средствами numpy и/или pandas. Не использовать циклы и конструкции стандартного Python там, где можно использовать возможности данных библиотек.
#
# Поиск самого частого числа:
#
# np.unique с параметром return_counts=True возвращает уникальные значения и их количество
#
# np.argmax(counts) находит индекс самого частого числа
#
# Поиск позиций:
#
# np.argwhere находит все индексы, где встречается самое частое число
#
# Подсчет в строках:
#
# np.sum(arr == most_common_value, axis=1) считает количество самых частых чисел в каждой строке
#
# Выбор строк:
#
# np.argsort(counts_per_row)[-3:] находит индексы 3 строк с наибольшим количеством
#
# arr[top3_rows] извлекает эти строки
#
# 5
print(f"\nЗадание 5\n")
arr = np.random.randint(0, 51, size=(10, 4)) # Создаем массив 10x4 со случайными числами от 0 до 50

values, counts = np.unique(arr, return_counts=True) # Находим самое частое число в массиве
most_common_value = values[np.argmax(counts)]
max_count = np.max(counts)

positions = np.argwhere(arr == most_common_value) # Находим все позиции самого частого числа
counts_per_row = np.sum(arr == most_common_value, axis=1) # Считаем количество самых частых чисел в каждой строке == axis=1

top3_rows = np.argsort(counts_per_row)[-3:] # Находим 3 строки с наибольшим количеством самых частых чисел
result = arr[top3_rows]
print("Исходный массив:")
print(arr)
print(f"\nСамое частое число: {most_common_value} (встречается {max_count} раз)")
print("Его позиции в массиве (строка, столбец):")
print(positions)
print("\n3 строки с наибольшим количеством самых частых чисел:")
print(result)
#
# 6.
# Приблизительно (с погрешностью порядка 1%) рассчитать на какой части прямоугольника  значение функции  больше 0.25.
# Решить задачу средствами numpy и/или pandas. Не использовать циклы и конструкции стандартного Python там, где можно использовать возможности данных библиотек.
#
# 6
print(f"\nЗадание 6\n")
# Создаем сетку значений x и y
x = np.linspace(0, 5, 1000)  # 1000 точек для высокой точности
y = np.linspace(0, 5, 1000)
X, Y = np.meshgrid(x, y)
Z = X * Y * np.sin(X) * np.cos(Y)
# Находим долю точек, где Z > 0.25
area_ratio = np.mean(Z > 0.25)
# Выводим результат в процентах с округлением до 1%
print(f"Доля площади, где z(x, y) > 0.25: {area_ratio * 100:.1f}%")